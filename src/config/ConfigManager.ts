import type { 
  TowerConfig, 
  EnemyConfig, 
  ProjectileConfig, 
  MapConfig
} from './ConfigTypes.js';

export class ConfigManager {
  private static instance: ConfigManager;
  
  private towerConfigs = new Map<string, TowerConfig>();
  private enemyConfigs = new Map<string, EnemyConfig>();
  private projectileConfigs = new Map<string, ProjectileConfig>();
  private mapConfigs = new Map<string, MapConfig>();
  
  private initialized = false;
  
  private constructor() {}
  
  static getInstance(): ConfigManager {
    if (!ConfigManager.instance) {
      ConfigManager.instance = new ConfigManager();
    }
    return ConfigManager.instance;
  }
  
  async initialize(): Promise<void> {
    if (this.initialized) return;
    
    try {
      // Load all configurations
      await Promise.all([
        this.loadTowerConfigs(),
        this.loadEnemyConfigs(),
        this.loadProjectileConfigs(),
        this.loadMapConfigs()
      ]);
      
      this.initialized = true;
      console.log('ConfigManager initialized successfully');
      console.log(`Loaded: ${this.towerConfigs.size} towers, ${this.enemyConfigs.size} enemies, ${this.projectileConfigs.size} projectiles, ${this.mapConfigs.size} maps`);
    } catch (error) {
      console.error('Failed to initialize ConfigManager:', error);
      throw error;
    }
  }
  
  private async loadTowerConfigs(): Promise<void> {
    // For now, we'll manually list the available configurations
    // In a more advanced setup, this could be generated by a build process
    const towerFiles = ['basic_tower'];
    
    for (const filename of towerFiles) {
      try {
        const config = await this.loadJsonFile<TowerConfig>(`/config/towers/${filename}.json`);
        this.validateTowerConfig(config);
        this.towerConfigs.set(config.id, config);
      } catch (error) {
        console.warn(`Failed to load tower config ${filename}:`, error);
      }
    }
  }
  
  private async loadEnemyConfigs(): Promise<void> {
    const enemyFiles = ['basic_enemy'];
    
    for (const filename of enemyFiles) {
      try {
        const config = await this.loadJsonFile<EnemyConfig>(`/config/enemies/${filename}.json`);
        this.validateEnemyConfig(config);
        this.enemyConfigs.set(config.id, config);
      } catch (error) {
        console.warn(`Failed to load enemy config ${filename}:`, error);
      }
    }
  }
  
  private async loadProjectileConfigs(): Promise<void> {
    const projectileFiles = ['basic_projectile'];
    
    for (const filename of projectileFiles) {
      try {
        const config = await this.loadJsonFile<ProjectileConfig>(`/config/projectiles/${filename}.json`);
        this.validateProjectileConfig(config);
        this.projectileConfigs.set(config.id, config);
      } catch (error) {
        console.warn(`Failed to load projectile config ${filename}:`, error);
      }
    }
  }
  
  private async loadMapConfigs(): Promise<void> {
    const mapFiles = ['basic_map'];
    
    for (const filename of mapFiles) {
      try {
        const config = await this.loadJsonFile<MapConfig>(`/config/maps/${filename}.json`);
        this.validateMapConfig(config);
        this.mapConfigs.set(config.id, config);
      } catch (error) {
        console.warn(`Failed to load map config ${filename}:`, error);
      }
    }
  }
  
  private async loadJsonFile<T>(path: string): Promise<T> {
    try {
      // Use fetch to load JSON files in browser environment
      const response = await fetch(path);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      return await response.json();
    } catch (error) {
      throw new Error(`Failed to load ${path}: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  // Validation methods
  private validateTowerConfig(config: any): asserts config is TowerConfig {
    if (!config.id || typeof config.id !== 'string') {
      throw new Error('Tower config missing or invalid id');
    }
    if (!config.health?.maximum || typeof config.health.maximum !== 'number') {
      throw new Error('Tower config missing or invalid health.maximum');
    }
    if (!config.attack?.damage || typeof config.attack.damage !== 'number') {
      throw new Error('Tower config missing or invalid attack.damage');
    }
    // Add more validation as needed
  }
  
  private validateEnemyConfig(config: any): asserts config is EnemyConfig {
    if (!config.id || typeof config.id !== 'string') {
      throw new Error('Enemy config missing or invalid id');
    }
    if (!config.health?.maximum || typeof config.health.maximum !== 'number') {
      throw new Error('Enemy config missing or invalid health.maximum');
    }
    if (!config.movement?.baseSpeed || typeof config.movement.baseSpeed !== 'number') {
      throw new Error('Enemy config missing or invalid movement.baseSpeed');
    }
    // Add more validation as needed
  }
  
  private validateProjectileConfig(config: any): asserts config is ProjectileConfig {
    if (!config.id || typeof config.id !== 'string') {
      throw new Error('Projectile config missing or invalid id');
    }
    if (typeof config.damage !== 'number') {
      throw new Error('Projectile config missing or invalid damage');
    }
    if (typeof config.speed !== 'number') {
      throw new Error('Projectile config missing or invalid speed');
    }
    // Add more validation as needed
  }
  
  private validateMapConfig(config: any): asserts config is MapConfig {
    if (!config.id || typeof config.id !== 'string') {
      throw new Error('Map config missing or invalid id');
    }
    if (typeof config.width !== 'number' || typeof config.height !== 'number') {
      throw new Error('Map config missing or invalid width/height');
    }
    // Add more validation as needed
  }
  
  // Getter methods
  getTowerConfig(id: string): TowerConfig | undefined {
    return this.towerConfigs.get(id);
  }
  
  getEnemyConfig(id: string): EnemyConfig | undefined {
    return this.enemyConfigs.get(id);
  }
  
  getProjectileConfig(id: string): ProjectileConfig | undefined {
    return this.projectileConfigs.get(id);
  }
  
  getMapConfig(id: string): MapConfig | undefined {
    return this.mapConfigs.get(id);
  }
  
  // Get all configs of a type
  getAllTowerConfigs(): TowerConfig[] {
    return Array.from(this.towerConfigs.values());
  }
  
  getAllEnemyConfigs(): EnemyConfig[] {
    return Array.from(this.enemyConfigs.values());
  }
  
  getAllProjectileConfigs(): ProjectileConfig[] {
    return Array.from(this.projectileConfigs.values());
  }
  
  getAllMapConfigs(): MapConfig[] {
    return Array.from(this.mapConfigs.values());
  }
  
  // Utility methods
  getTowerIds(): string[] {
    return Array.from(this.towerConfigs.keys());
  }
  
  getEnemyIds(): string[] {
    return Array.from(this.enemyConfigs.keys());
  }
  
  isInitialized(): boolean {
    return this.initialized;
  }
}